---
title: "Longitudinal Motif Detection"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Longitudinal Motif Detection}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 10,
  fig.height = 5,
  out.width = "100%"
)
```

## Introduction

This vignette demonstrates how to detect and analyze song motifs across 
**longitudinal recordings** using SAP objects and optimized template parameters.

**Prerequisites**: Before reading this vignette, we recommend completing:

- [Overview: Basic Audio Analysis](single_wav_analysis.html) - Core ASAP functions
- [Motif Detection](motif_detection.html) - Template optimization workflow
- [Constructing SAP Object](construct_sap_object.html) - SAP object creation

## Overview

The longitudinal motif detection workflow applies the template parameters you 
optimized on a single recording (see [Motif Detection](motif_detection.html)) 
across all recordings in a SAP object.

![Longitudinal Motif Detection Pipeline](figures/longitudinal_pipeline.png)

## Complete Pipeline

```{r pipeline, eval = FALSE}
library(ASAP)

# Load or create SAP object
sap <- create_sap_object(
  base_path = "/path/to/recordings",
  subfolders_to_include = c("190", "201", "203"),
  labels = c("Baseline", "Post", "Recovery")
)

# Run the complete motif detection pipeline
sap <- sap |>
  create_audio_clip(indices = 1, 
                    start_time = 1, 
                    end_time = 2.5, 
                    clip_names = "motif_ref") |>
  create_template(template_name = "syllable_d", 
                  clip_name = "motif_ref",
                  start_time = 0.72, 
                  end_time = 0.84,
                  freq_min = 1, 
                  freq_max = 10, 
                  threshold = 0.5, 
                  write_template = TRUE) |>
  detect_template(template_name = "syllable_d",
                  threshold = 0.5,
                  proximity_window = 1) |>
  find_motif(template_name = "syllable_d", 
             pre_time = 0.7, 
             lag_time = 0.5)
```

### Understanding SAP Object Behavior

**1. Metadata-Based Lazy Loading**

After creating the SAP object, you have a metadata index (stored in `sap$metadata`) 
that references all audio files by their paths and timestamps. The actual WAV file 
data is **not loaded into memory**â€”files are read on-demand during analysis. This 
means:

- The SAP object remains lightweight even with thousands of recordings
- **All subsequent pipeline steps require the original WAV files to be accessible** 
  at their original paths
- If you move or delete the audio files, the pipeline will fail

**2. Centralized Result Storage**

The SAP object stores all analysis results in a structured format, making it easy 
to access detection outcomes:

```r
# Access template detection results
sap$templates$template_matches[["syllable_d"]]

# Access extracted motif boundaries (onset/offset timestamps)
sap$motifs  # Data frame with start_time, end_time for each detected motif

# Access spectral features (if analyze_spectral() was run)
sap$features$motif$spectral_feature
```

**3. Optional Template Detection Visualizations**

If you set `write_template = TRUE` in `create_template()`, spectrogram images 
of template detections are saved to a local directory (typically `templates/` 
within your base path). These images are **not stored in the SAP object** but 
can be useful for quality control and manual inspection of detection accuracy.

**Example output:**

```{r pipeline-output, echo = FALSE, eval = TRUE, comment = ""}
cat("=== Starting Template Detection ===

Processing 312 files for day 190 using 7 cores.
Processed files in day 190. Total detections: 1247

Processing 285 files for day 201 using 7 cores.
Processed files in day 201. Total detections: 1089

Processing 250 files for day 203 using 7 cores.
Processed files in day 203. Total detections: 956

Total detections across all days: 3292
Access detection results via: sap$templates$template_matches[[\"syllable_d\"]]")
```

## Visualizing Results

```{r visualize, eval = FALSE}
# View detection summary
summary(sap$motifs)

# Visualize sample motifs from each time point
visualize_segments(sap, 
                   segment_type = "motifs", 
                   n_samples = 3)
```

```{r visualize-segments-output, echo = FALSE, eval = TRUE, out.width = "100%", fig.cap = "Sample motif spectrograms across developmental time points."}
# Placeholder for pre-computed image
if (file.exists("figures/longitudinal_segments.png")) {
  knitr::include_graphics("figures/longitudinal_segments.png")
} else {
  message("Image placeholder: figures/longitudinal_segments.png")
}
```

### Amplitude Envelope Heatmap

```{r heatmap, eval = FALSE}
# Create amplitude envelope heatmap
sap |> plot_heatmap(balanced = TRUE)
```

```{r heatmap-output, echo = FALSE, eval = TRUE, out.width = "100%", fig.cap = "Amplitude envelope heatmap showing temporal structure across time points."}
# Placeholder for pre-computed image
if (file.exists("figures/longitudinal_heatmap.png")) {
  knitr::include_graphics("figures/longitudinal_heatmap.png")
} else {
  message("Image placeholder: figures/longitudinal_heatmap.png")
}
```

## Feature Extraction and Analysis

```{r features, eval = FALSE}
# Extract spectral features
sap <- sap |>
  analyze_spectral(balanced = TRUE) |>
  find_clusters() |>
  run_umap()

# Visualize UMAP by time point
sap |> plot_umap(split.by = "label")
```

```{r umap-output, echo = FALSE, eval = TRUE, out.width = "100%", fig.cap = "UMAP visualization of motif features colored by developmental time point."}
# Placeholder for pre-computed image
if (file.exists("figures/longitudinal_umap.png")) {
  knitr::include_graphics("figures/longitudinal_umap.png")
} else {
  message("Image placeholder: figures/longitudinal_umap.png")
}
```

## Key Parameters for Longitudinal Analysis

| Parameter | Location | Description |
|-----------|----------|-------------|
| `threshold` | `create_template()` / `detect_template()` | Minimum correlation score. Adjust in `detect_template()` to refine without recreating template. |
| `proximity_window` | `detect_template()` | Filter duplicate detections within this time window (seconds). |
| `balanced` | `analyze_spectral()` / `plot_heatmap()` | Balance samples across time points. |

## Tips for Longitudinal Analysis

1. **Optimize parameters first**: Use the single-file workflow in 
   [Motif Detection](motif_detection.html) before bulk processing.

2. **Check detection quality**: Visualize sample detections from each time point 
   to verify template works across developmental stages.

3. **Adjust threshold if needed**: If detection rates vary significantly across 
   time points, consider adjusting the threshold in `detect_template()`.

4. **Use balanced sampling**: When comparing across time points, use 
   `balanced = TRUE` to ensure equal representation.

## Session Info

```{r session-info}
sessionInfo()
```
